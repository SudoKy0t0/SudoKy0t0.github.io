---
layout: posts
title: "CVE-2025-4138 and CVE-2025-4517"
date: 2026-02-15
tags: [cve, linux, web]
categories: [cve]
---

### Vulnerability Description

CVE-2025-4138 is a path boundary enforcement bypass in Python’s tarfile extraction filter caused by improper handling of excessively long paths during archive member validation. This flaw allows a specially crafted tar archive to escape the intended extraction directory.

In simpler terms, the vulnerability is a bug in Python’s tarfile module where the built-in safety mechanism (filter="data") can be bypassed. The filter is designed to prevent archive contents from writing files outside the directory chosen for extraction. However, if an attacker creates a malicious archive using extremely long file paths, the safety checks can fail.

As a result, arbitrary files may be written outside the target extraction directory when using:

> `TarFile.extract()`

> `TarFile.extractall()`

with filter="data" enabled.

### How tarfile.extractall() Works Internally

For this section, we refer to both the official Python [documentation](https://docs.python.org/3/library/tarfile.html#tarfile-objects) and the CPython source code.

The tar archive is parsed sequentially and each entry inside the archive becomes a TarInfo object containing metadata:

- name (filename/path inside archive)
- type (regular file, directory, symlink, etc.)
- linkname (for symlinks/hardlinks)
- permissions
- ownership
- size

If we take a look at the python repository, in the vulnerable version [Lib/tarfile.py](https://github.com/python/cpython/blob/v3.12.10/Lib/tarfile.py) and search for the extractall() method, we can see it's running on a loop for every object member the tar file. So, basically, it would be something like:

```python
for member in tar.getmembers():
    self.extract(member, path=..., filter=...)
```

Before extraction, the optional filter is applied. When filter="data" is used, Python performs validation checks on the archive member to detect unsafe conditions.

Next, python constructs an extraction path for each member:

```python
target_path = os.path.join(base_path, member.name)
normalized = os.path.normpath(target_path)
```
Then it normalizes it through `_get_extract_tarinfo`

This produces something like:

```python
/safe/dir/some/file.txt
```

At this stage, Python determines whether the path is considered safe. Importantly, this validation occurs at the string level before the filesystem performs its own path resolution.

This distinction is critical to understanding CVE-2025-4138.

### What is filter="data" Intended For?

Historically, tarfile.extractall() has been unsafe by default.

For example:

```python
tar.extractall("/safe/dir")
```

If the archive contains a file such as:

```bash
../../etc/passwd
```

Python would extract it outside `/safe/dir`.

This is the classic path traversal vulnerability in tar extraction.

To address this, Python introduced extraction filters in version 3.12. The main purpose of filter="data" is to make tar extraction safer by preventing archive entries from escaping the selected extraction directory.

Specifically, filter="data" attempts to block:

../ directory traversal

Absolute paths (e.g., /etc/passwd)

Symlinks pointing outside the extraction directory

Hard links to external locations

Special device files (e.g., block or character devices)

It is called "data" because it treats archive entries strictly as plain data files rather than as full Unix filesystem objects.

### Root cause analysis

### What is PATH_MAX?

PATH_MAX is a system-defined constant representing the maximum allowed length of a filesystem path. The value varies depending on the operating system.

On most Linux systems:


```bash
PATH_MAX = 4096 bytes
```

On macOS:

```macOS
PATH_MAX = 1024 or 4096 (depends on configuration)
```

It is defined in:

```bash
#include <limits.h>
```

It's important to emphasize that this constant is enforced by the kernel, Python itself does not enforce path length limits, the kernel does and usually, these types of constraints are enforced when performing a file operation in linux (e.g., open(), mkdir(), symlink()).

### What Happens When a Path Exceeds PATH_MAX?

When a path inside a tar archive is extremely long, Python can still construct and normalize it as a string without issue. The validation logic in `filter="data"` operates purely on that normalized string and may approve it as *safe*.

However, actual path resolution occurs at the operating system level when filesystem operations such as `open()` or `mkdir()` are executed. The kernel resolves paths component by component and enforces constraints such as PATH_MAX and symlink traversal rules during this process.

If the archive contains `deeply nested paths` combined with `symlinks`, the real resolution performed by the kernel may not match the logical path that Python validated. In other cases involving extremely long paths, resolution behavior can differ from Python’s stringbased assumptions.

This creates a `mismatch` between static validation performed by Python (string + metadata) and the dynamic resolution performed by the kernel (real filesystem traversal).

The root cause of CVE-2025-4138 lies in this mismatch. Under certain crafted conditions, a path that appears safe during validation may resolve differently during extraction, allowing boundary enforcement to be bypassed.

### CVE-2025-4517

CVE-2025-4517 exists because the initial fix for CVE-2025-4138 did not fully eliminate the mismatch between validation and real filesystem resolution.

The first patch tightened boundary checks but it still relied on assumptions about how path resolution behaves.

### Why the First Patch Failed

The initial fix for CVE-2025-4138 attempted to:

> Harden path normalization.
> Improve boundary enforcement.
> Reject certain long-path edge cases.
> Strengthen checks around symlink handling.

The bypass succeeded because the validation logic was an approximation of kernel resolution semantics rather than an exact reproduction of them.

### Exploit Walkthrough (Conceptual)

By creating a deeply nested path containing a symlink that resolves outside the extraction directory, an attacker can cause the kernel to write files outside the intended boundary. Although the string-based validation phase approves the logical path, the kernel’s component-by-component resolution follows the symlink during the actual write operation, bypassing boundary enforcement.

I'll cite this very useful PoC published by [DesertDemons](https://github.com/DesertDemons/CVE-2025-4138-4517-POC/blob/main/exploit.py)

### Inflate the resolved path to PATH_MAX

The script builds:

```bash
dir(247 chars)/symlink → dir
dir(247 chars)/symlink → dir
dir(247 chars)/symlink → dir
...
(repeated ~16 times)
```

So you get a structure like:

```bash
a → longdir
b → longdir
c → longdir
...
```

so each level has a short name on disk and a huge resolved path when expanded.

After about 16 levels the resolved path will approxemately be 3968 bytes which is very close to our `PATH_MAX = 4096` and now any further resolution will exceed PATH_MAX.

### Create the Escape Symlink

Now the script adds:

```bash
pivot_symlink → ../../../../../../..
```

When Python checks it with os.path.realpath(), it tries to resolve but the resolved path is already near PATH_MAX so realpath() stops expanding and it passes the filter because it's on a safe dir.

Next extraction happens, and as mentioned beforehand, the kernel does this dynamically, which will allow us to traverse directories succesfully.

### Final Arbitrary File Write

The archive then writes:

```bash
escape/target_file
```

But escape symlink now resolves to:

`/`

So depending on the payload, the file may land in:

```bash
/etc/passwd
/root/.ssh/authorized_keys
/etc/cron.d/pwned
```

### Conclusion

CVE-2025-4138 and CVE-2025-4517 show how difficult it can be to safely extract archives using only path checks in user space. Filesystem path resolution is handled by the operating system and can behave in ways that are hard to perfectly reproduce in application code. When validation relies only on string checks, small differences between how a program interprets a path and how the OS actually resolves it can open the door to bypasses. The safest approach is to rely on the operating system to enforce boundaries wherever possible, carefully control how symbolic links are handled, and avoid trying to fully replicate filesystem behavior in user-space logic alone.
