---
title: "CVE-2025-4138 and CVE-2025-4517"
published: false
---


### Vulnerability Description

CVE-2025-4138 is a path boundary enforcement bypass in Python’s tarfile extraction filter caused by improper handling of excessively long paths during archive member validation. This flaw allows a specially crafted tar archive to escape the intended extraction directory.

In simpler terms, the vulnerability is a bug in Python’s tarfile module where the built-in safety mechanism (filter="data") can be bypassed. The filter is designed to prevent archive contents from writing files outside the directory chosen for extraction. However, if an attacker creates a malicious archive using extremely long file paths, the safety checks can fail.

As a result, arbitrary files may be written outside the target extraction directory when using:

> `TarFile.extract()`

> `TarFile.extractall()`

with filter="data" enabled.

### How tarfile.extractall() Works Internally

For this section, we refer to both the official Python [documentation](https://docs.python.org/3/library/tarfile.html#tarfile-objects) and the CPython source code.

The tar archive is parsed sequentially and each entry inside the archive becomes a TarInfo object containing metadata:

- name (filename/path inside archive)
- type (regular file, directory, symlink, etc.)
- linkname (for symlinks/hardlinks)
- permissions
- ownership
- size

If we take a look at the python repository, in the vulnerable version [Lib/tarfile.py](https://github.com/python/cpython/blob/v3.12.10/Lib/tarfile.py) and search for the extractall() method, we can see it's running on a loop for every object member the tar file. So, basically, it would be something like:

```python
for member in tar.getmembers():
    self.extract(member, path=..., filter=...)
```

Before extraction, the optional filter is applied. When filter="data" is used, Python performs validation checks on the archive member to detect unsafe conditions.

Next, python constructs an extraction path for each member:

```python
target_path = os.path.join(base_path, member.name)
normalized = os.path.normpath(target_path)
Then it normalizes it through `_get_extract_tarinfo`
```

This produces something like:

```python
/safe/dir/some/file.txt
```

At this stage, Python determines whether the path is considered safe. Importantly, this validation occurs at the string level before the filesystem performs its own path resolution.

This distinction is critical to understanding CVE-2025-4138.

### What is filter="data" Intended For?

Historically, tarfile.extractall() has been unsafe by default.

For example:

```python
tar.extractall("/safe/dir")
```

If the archive contains a file such as:

```bash
../../etc/passwd
```

Python would extract it outside `/safe/dir`.

This is the classic path traversal vulnerability in tar extraction.

To address this, Python introduced extraction filters in version 3.12. The main purpose of filter="data" is to make tar extraction safer by preventing archive entries from escaping the selected extraction directory.

Specifically, filter="data" attempts to block:

../ directory traversal

Absolute paths (e.g., /etc/passwd)

Symlinks pointing outside the extraction directory

Hard links to external locations

Special device files (e.g., block or character devices)

It is called "data" because it treats archive entries strictly as plain data files rather than as full Unix filesystem objects.

### Root cause analysis

### What is PATH_MAX?

PATH_MAX is a system-defined constant representing the maximum length of a filesystem path. This number varies between OS:

On most Linux systems:


```bash
PATH_MAX = 4096 bytes
```

On macOS:

```macOS
PATH_MAX = 1024 or 4096 (depends on configuration)
```

It is defined in:

```bash
#include <limits.h>
```

It's important to emphasize that this constant is enforced by the kernel, Python itself does not enforce path length limits.

`But the kernel does`

Usually, these types of constraints are enforced when performing a file operation in linux (e.g., open(), mkdir(), symlink()).

### What Happens When a Path Exceeds PATH_MAX?

When the path becomes extremely long, Python will build the full string and validation logic runs on that full string. It may pass validation but when the OS tries to resolve it, the kernel may reject it.

This will create a mismatch between logical validation and physical resolution.

The root cause of CVE-2025-4138 lies in the mismatch between string-based path validation performed by tarfile and the kernel-level path resolution process. When archive member paths exceed system-defined limits such as PATH_MAX, the validation logic may approve a path that the filesystem ultimately resolves differently, allowing boundary enforcement to be bypassed.

To put it simply, Python checks the path as text, but the operating system enforces real path limits. When a path is extremely long, those two checks can disagree and that disagreement allows the protection to be bypassed.
